%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   Semester project, fall term 2014
%   Author: Jakob Ehrl, born 01/24/91
%   Study program: Computer science, MA 1
%   
%   Professor Dr. Francesco Mondada
%   Assistant: Dr. Stefan Witwicki
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Central Processing}

\section{Setup of Processing Units}
Our robot is equipped with four different processing units that, together,
form a network of workers performing individual tasks. There is one master
node that receives sensor readings and lower level computation results from
the other nodes. This data is used to make decisions and finally send 
commands to control the actuators.


\subsection{Master Node}
An Odroid-C1 was used as master node. Similar to the well known Raspberry Pi,
this miniature computer has a Unix-based operating system and posses numerous
ports such as USB, Ethernet, HDMI and various GPIO pins. We decided to use this
board instead of the Raspberry Pi, which is available in the virtual catalog,
because of the way we intended to design the network of processing units and 
data processing. With four USB ports instead of only two, four CPU cores and twice 
the amount of SDRAM, the Odroid-C1 allows to easily connect the other processing 
boards as well as a camera over USB. The quad-core processor justifies the use
of multiple threads and allows to process data from different inputs independently
instead of in a single-loop program.

\subsection{Slaves} 
\subsubsection{Arduino Micro 1}
\subsubsection{Arduino Micro 2}
\subsubsection{Wild Thumper Controller}

\subsection{Communication}
To transmit data acquired by the Arduino boards and commands generated by the master,
we use the serial communication protocol. The micro controllers do not communicate with
each other. On both sides of the transmission there is a timed control loop that reads
and writes data at a frequency of 30 Hz. All the available information is first 
stored in a buffer. After full transmission the data is processed (commands executed, 
readings considered in control algorithm).

\subsubsection{Message Format}
A message is composed of four ASCII characters. The first character being either an
upper- or lowercase character and the following three characters being digits with
leading zeros. Uppercase letters denote command IDs while lowercase letters denote
sensor IDs. Any number between 0 and 999 is allowed as respective value. 

\subsubsection{Limiting Factors}
Since Arduino boards have a small buffer for serial communication (64 bytes), continuous
communication causes a major bottleneck on the micro controllers. Therefore we 
had to limit the update frequency to 30 Hz and also limit the number of messages
that can be sent per iteration.

\section{Vision}

\subsection{Camera}

\subsection{Terrain Segmentation}
Integral image from color image. Assuming that terrain directly in front of robot is 
drivable, we extend this area while ensuring that the color does not change too much.

\subsection{Object Detection}

\subsection{Light}
Lightning conditions play a decisive roll in most vision applications. In this
particular scenario we are blessed with nearly optimal lighting coming from the
ceiling. Due to the vision algorithm design and manual tuning of camera exposure time
our images do not suffer from saturation.

\section{Control Algorithm}
At the moment our robot is a Braitenberg vehicle, meaning that depending on the type
of reading it receives steers its wheels toward or away from the perceived object. 
Terrain classification as well as positions of obstacles and bottles detected through 
vision will be added to guide the robot. Special behaviors as picking up a bottle, 
returning home to the recycling station or releasing loaded bottles are planned.
